---
title: 关于图片加载的性能优化
date: 2017-06-24 22:20:47
tags:
  - 优化
---
#### 前奏
图片资源在web项目中非常的重要,据统计,图片内容已经占到了互联网内容总量的62%,那么优化图片资源是非常必要的

#### 图片的加载机制
 即时加载时最常见的加载方式,通过img标签的src属性制定加载的图片url地址
 
 ```
 <img src="http://" alt=""/>
 <img src="http://" alt=""/>
 <img src="http://" alt=""/>
 ```
 特点:
 
 - 浏览器大部分并发下载,图片的下载没有阻塞
 - src相同的图片,不会多次下载
 - 图片的下载和渲染会阻塞整个页面的渲染
 - 图片越大,下载的时间越长
 
#### 在web端加载图片时优化的处理方法
   1. 图片的延迟加载
  也叫做图片的懒加载,当网页中图片比较多的时候,加载太多图片的速度会非常慢,所以会采用初次加载的时候只显示可视区域的图片,当页面滚动时再依次进行加载,这样可以显著的提高页面的加载速度,同时图片的请求数量减少也减轻了服务器的压力,具体的实现方式是,src属性上写的是一个小图,滚动时将img的src属性换成真实图片地址.

    ```
    <p><img src="" realImg="img/022222222.jpg" alt=""/></p>
    ```

    js部分如下
    
    ```
    var oImg=document.getElementsByTagName('img')[0];
    window.onscroll=function(){
        var scrollBottom=utils.win('scrollTop')+utils.win('clientHeight');
        var imgPos=utils.offset(oImg).top+utils.getCss(oImg,'height');
        //判断图片是否满足显示的条件
        if(imgPos<scrollBottom){
                lazyImg();
        }
    };
    function lazyImg(){
            //避免重复加载
            if(oImg.loaded) return;
            //图片可以加载了；
            //先找一个临时的替身图片
            var tmpImg=new Image();//document.createElement('img');
            //替身图片来验证图片地址是否有效
            tmpImg.src=oImg.getAttribute('realImg');
            //图片地址正确，可以成功加载
            tmpImg.onload=function(){
                oImg.src=this.src;
                oImg.loaded=true;//避免重复加载
                tmpImg=null;//释放对象，提高性能；
            };
            tmpImg.onerror=function(){
                oImg.parentNode.style.backgroundImage='url("img/error.gif")';
                oImg.loaded=true;
                tmpImg=null;
            }
        }    
    ```
    
  2. 使用base64编码代替图片
    * 用在:适用于图片小于2kb,页面上引用次数少的.
    * 原理:将图片转为base64编码字符串放在页面中或者css中返回给前端
    * 好处:减少http请求次数,只传输字符串.
    * 缺点:仅限于图片总数少并且图片比较小的,否在服务端返回的时候性能也会差.
    
  3. 合并图片sprite(雪碧图)
    对于任何项目中,这种方式都适用,把多张图片合并在一张大图上,根据位移来计算图片的坐标,优点是可以有效的减少请求个数,但同时也增加了这个大图的图片体积,所以这种方式可以合理使用
    
  4. 使用css  svg canvas 或者iconfont代替图片
    ##### css代替图片
     场景：适用于移动端或较高级的浏览器，而且绘制的图案较为简单。
     原理：css方式可以用来绘制相对简单的团来代替图片，一般使用before或者after伪元素来丰富图案的复杂度。
     优势：具有实现简单，图片体积小的特点，可以实现简单的动态效果
     劣势：也受限于css的兼容性特点，绘制复杂图案困难
    ##### svg
     是一种矢量图片，支持透明，缩放，动画，除了android 2.3的手机，其它场景都支持，是一种比较好的图片代替方案。
     优势：
     矢量图形，不受像素影响在不同的平台或者媒体下表现良好，无论屏幕分辨率如何
     SVG对动画的支持较好；其DOM结构可以被其特定语法或者Javascript控制，从而轻松的实现动画,Javascript可以完全控制SVG Dom 元素,音乐播放的矢量图按钮等都是用svg图标.
     SVG的结构是 XML，其可访问性（盲文、声音朗读等）、可操作性、可编程性、可被CSS样式化完胜Canvas。
     劣势：
     DOM比正常的图形慢，而且如果其结点多而杂，就更慢了
     不适合网页游戏等；当然，我们可以结合 Canvas + SVG来实现  
    ##### canvas代替图片
     场景：需要高性能的图片或动画
     原理：适用html5的canvas元素绘制创建图片
     优势：整个就是画2D图形时，页面渲染性能比较高，页面渲染性能受图形复杂度影响小，性能只受图形的分辨率的影响，画出来的图形可以直接保存为 .png 或者 .jpg的图形，适合于画光栅图像或者不规则图形
     劣势：没有dom操作，必须依赖定时器，文字渲染性能差，不能添加描述(title属性什么的)，兼容性限制
    ##### iconfont是一种web字体来代替图片的解决方案：
     场景：代替页面上色彩单一的图片
     优势：兼容性好，应用广，目前使用也很广泛
     劣势：但是由于字体的颜色设置单一，只能用于代替颜色单一的图片，对于色彩复杂的图片，iconfont处理起来比较困难
     但是对于一般的web图标,字体图标是很受用的.而且在bootrap下的Glyphicons字体图标也是其中一种.
     
  5. 如果避免不了,必须加载图片,我们也可以进行图片压缩
     对图片进行无损、有损压缩，转为压缩后图片来实现
     优势：减少图片加载流量，效果比较明显
     劣势：服务器和浏览器压力增大，而且服务器需要额外的服务支持
     
     这种情况下,我是用node在路由中处理了一下,用node请求图片,然后用grunt完成图片的压缩.
     如果是前台传给后台的图片时,图片太大,那就用canvas,降低图片质量,然后将base64串传给后台.